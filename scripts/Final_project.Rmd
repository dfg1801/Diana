---
title: "Final Project"
author: "Diana Gao"
date: "2024-12-10"
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 4
    df_print: paged
    
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      message = FALSE, 
                      warning = FALSE, 
                      fig.path = "../output/") #set directory for the figures to go in to
require(Hmisc)
```

`r Hmisc::hidingTOC(hidden=TRUE,levels=0)`

Hi! Welcome to my final project page. Some background info: for birds, there is evidence of beak morphology being highly related to feeding ecology. The HI honeycreepers are an adaptive radiation with crazy variation in beak morphology, which leads people to believe that their 
But just looking at the birds' beaks and diets, it seems like many similar feeding ecologies still yield a lot of different beak shapes. I wanted to see if there is correlation between difference in beak morphology and phylogenetic distance, maybe hinting at the interaction between a species' lineage and their feeding ecology shaping their morphology. Are we able to predict species' morphological differences based on their phylogenetic difference? What does this pattern look like? 
My first set of morphological data is taken from [AVONET](https://opentraits.org/datasets/avonet.html). The landmarks for the measurements are written in the data dictionary, but here is a figure from their paper which visually shows the measurement methods. Note number 1, 3, and 4 in particular. 

![](C:/Users/diana/OneDrive/Desktop/Homeworks nd sylabus/Data science class/Diana_Final/data/Measurement_diagram.PNG)

The second set of morphological info is from "Beak morphometry and morphogenesis across avian radiations"

# Setup

### Load Packages

```{r}
library(tidyverse)
library(here)
library(janitor)
library(reshape2) # for working with matrices
library(phytools) # for working with phylo data
library(patchwork)
library(car)
library(ggResidpanel)
library(VGAM)

#functions
bmMLE <- function(phy, x) {
  #browser() is debug mode
    # calculate VCV matrix and inverse
    S <- ape::vcv(phy, model = 'Brownian', corr = FALSE)
    Sinv <- solve(S)

    # a vector of 1s for matrix math below
    one <- rep(1, nrow(Sinv))

    # MLE of trait value at root
    x0 <- as.vector(solve(one %*% Sinv %*% one) %*% (one %*% Sinv %*% x))

    # MLE of BM variance
    s2 <- as.vector(((x - x0) %*% Sinv %*% (x - x0)) / nrow(Sinv))

    return(list(x0 = x0, s2 = s2, Smat = s2 * S))
}

```

### Load data

I will use bird morphological measurements from AVONET, combined with my own general info about honeycreepers. In addition, I will use the most-resolved currently published honeycreeper phylogeny from [Lerner et al. 2011](https://doi.org/10.1016/j.cub.2011.09.039), digitized by Dr. Matzke as part of [his paper](https://doi-org.eres.library.manoa.hawaii.edu/10.1093/sysbio/syu056), plotted below for your viewing pleasure :) 


```{r, tree}
data <- read_csv(here("data", "AVONET_Raw_Data.csv")) # avonet data
names <- read_csv(here("data", "Honeycreeper_info.csv")) # gathered honeycreeper info
data_3d <- read_csv(here("data", "clean_morpho_diet.csv")) # data from mosleh et al

# tree from lerner et al
tree_name <- file.path(here("data", "Lerner_etal_2011_CurrBio_honeycreepers_mod.newick"))
tree <- read.newick(tree_name)
plot(tree) # test that the tree read in correctly

# tree from luke campillo
tree_lc <- file.path("C:/Users/diana/OneDrive/Desktop/grad research/honeycreepers/phylopath_tree_rev/phylopath_tree_rev/output/all_finch_MRC.tree")
tree_lc <- read.tree(tree_lc)
plot(tree_lc)
```


# Cleaning

For this project, I will be using data from AVONET, an online database of bird data. In particular, I will be selecting out the HI honeycreepers within this dataset. There were many complications with this process because of multiple species having alternative scientific names as well as the phylogenetic data having a mix of the common or 'ōlelo names. Sigh. 

## Morphological data 

### From AVONET
```{r}
# first, clean self-generated creeper info --------------
names_clean <- names %>%
  clean_names()
# next clean + join avonet data to self generated dataset-----------------
morpho <- data %>%
  select(Avibase.ID:Publication) %>% # for some reason imported with a bunch of extra empty cols? 
  clean_names() %>% # clean names lol 
  #there are species with alternate names, so I want to make sure that if they are named under this name they are still captured within the dataset
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Hemignathus munroi", "Hemignathus wilsoni", .))) %>% #change alt sci names (munroi) into their primary names as listed in names_clean (wilsoni), . means if false keep value in cell currently
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Hemignathus flavus", "Chlorodrepanis flava", .))) %>%
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Hemignathus kauaiensis", "Chlorodrepanis stejnegeri", .))) %>%
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Loxops coccineus coccineus", "Loxops coccineus", .))) %>%
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Oreomystis mana", "Manucerthia mana", .))) %>%
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Loxops mana", "Manucerthia mana", .))) %>%
  mutate(across(species1_bird_life:species3_bird_tree, 
                ~ ifelse(. == "Hemignathus virens", "Chlorodrepanis virens", .))) %>%
  filter(species1_bird_life != "Himatione fraithii") %>% # this one particular sp seems to be mis-named as Himatione sanguinea in the birdtree dataset but im not sure? so I will remove these rows instead
  rename("sci_name" = species1_bird_life) %>% # make col names match for join
  inner_join(names_clean, by = "sci_name") %>%
  select(avibase_id, sci_name, hi_name, common_name, diet, detailed_diet, source:age, beak_length_culmen:tail_length) %>%
  mutate(common_name = coalesce(common_name, hi_name)) %>% # coalesce (frm dplyr) is good for replacing NAs with values from other vectors. if there is a missing common name, use the name from the hi_name column
  mutate(common_name = str_replace_all(common_name, "`", "")) %>% # get rid of tone markings so it can match the names from the phylo 
  mutate(common_name = str_replace_all(common_name, "ō", "o")) %>%
  mutate(common_name = str_replace_all(common_name, "ā", "a"))
```

So after all of that, we can finally have a nice table with all of our honeycreeper info and specimens' measurements from AVONET. The dietary info is taken from the HI DLNR website. Note that measurements are in mm (or g for body mass) Here it is: 
```{r, cols.print = 5}
morpho
```


### From Mosleh et al
```{r}
# done above already, clean self-generated creeper info --------------
names_clean <- names %>%
  clean_names()
#first, change sci names to full--------------------------
data_3d <- data_3d %>% 
  mutate(across(species,
         ~ ifelse(. == "C. flava", "Chlorodrepanis flava", .))) %>%
  mutate(across(species,   
         ~ ifelse(. == "C. stejnegeri", "Chlorodrepanis stejnegeri", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "C. virens", "Chlorodrepanis virens", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "H. sanguinea", "Himatione sanguinea", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "H. wilsoni", "Hemignathus wilsoni", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "L. bailleui", "Loxioides bailleui", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "L. caeruleirostris", "Loxops caeruleirostris", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "L. coccineus", "Loxops coccineus", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "M. mana", "Manucerthia mana", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "M. parva", "Magumma parva", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "M. phaeosoma", "Melamprosops phaeosoma", .))) %>%
  mutate(across(species,  
         ~ ifelse(. == "O. bairdi", "Oreomystis bairdi", .))) %>%  
  mutate(across(species,  
         ~ ifelse(. == "P. dolei", "Palmeria dolei", .))) %>% 
  mutate(across(species,  
         ~ ifelse(. == "P. montana", "Paroreomyza montana", .))) %>% 
  mutate(across(species,  
         ~ ifelse(. == "P. xanthophrys", "Pseudonestor xanthophrys", .))) %>% 
  mutate(across(species,  
         ~ ifelse(. == "T. cantans", "Telespiza cantans", .))) %>% 
  mutate(across(species,  
         ~ ifelse(. == "T. ultima", "Telespiza ultima", .))) %>% 
  mutate(across(species,  
         ~ ifelse(. == "V. coccinea", "Drepanis coccinea", .)))# Vestiaria coccinea = Drepanis coccinea

# now join with names
morpho_3d <- data_3d %>%
  rename(sci_name = species) %>%
  inner_join(names_clean, by = "sci_name") %>%
  select(sci_name, hi_name, common_name, diet.y, detailed_diet, width_2length:diet.x) %>%
  mutate(common_name = coalesce(common_name, hi_name)) %>% # coalesce (frm dplyr) is good for replacing NAs with values from other vectors. if there is a missing common name, use the name from the hi_name column
  mutate(common_name = str_replace_all(common_name, "`", "")) %>% # get rid of tone markings so it can match the names from the phylo 
  mutate(common_name = str_replace_all(common_name, "ō", "o")) %>%
  mutate(common_name = str_replace_all(common_name, "ā", "a"))
```


# Analysis/Results

My end goal for this analysis is to create scaled and normalilzed regressions of the pairwise phylogenetic and morphometric distances between each species in order to see if there is some relationship between the two which differs from the null. If I had more time, I would definetly add more statistical rigor but for now I am just trying to get things working. 

## Matrix making

But before comparing the pairwise  distances, we first have to generate them. First, I will average all the specimens within a species, then I will calculate pairwise distances. 

Luckily there is a function (stats::dist()) which does this. As well as (phytools::cophenetic.phylo()), which finds distances based on branch lengths from phylogenetic data. Once I make the matrices, then I melt them into a dataframe, with the important columns being the pair of names and the other being the distance between the pair. Whew! 

One thing I did do is to make sure to cut out pairwise distnaces between the same species as they are inherently going to be 0. I didn't want these 0s to skew the z-scoring and they are not informative data. 

### AVONET morphological Data

Again, so much cleaning so that the phylogenetic and morphological data can match. Also, I really struggled to make the matrix keep the species names for some reason T_T

#### Beak Length
This measurement is specifically for beak length to the culmen (see fig. 1). There was also beak length to the nares, but I arbitrarily chose to do this one. 

```{r}
#first cut up the table a bit
beak_length <- morpho %>%
  mutate(common_name = str_replace_all(common_name, " ", "_")) %>%
  mutate(common_name = str_replace_all(common_name, "Lesser_Amakihi", "Anianiau")) %>% # the phylo used diff names for these T_T
  mutate(common_name = str_replace_all(common_name, "Hawaii_akepa", "Akepa")) %>%
  mutate(common_name = str_replace_all(common_name, "Crested_honeycreeper", "Akohekohe")) %>%
  filter(common_name != "Akepa") %>% # akepa has no data so remove it from the matrix
  select(common_name, beak_length_culmen) %>%
  group_by(common_name) %>%
  summarise(mean_length_culmen = mean(beak_length_culmen)) %>%
  mutate(mean_length_culmen = scale(mean_length_culmen)) # scale measurements before calculating distances

# now make the pairwise distances
length_matrix=dist(beak_length)
length_matrix=as.matrix(length_matrix, labels=TRUE)
colnames(length_matrix) <- rownames(length_matrix) <- beak_length[['common_name']] #this line makes sure that the matrix retains the names

cleaned_length_dist <- length_matrix %>%
  melt() %>%
  filter(Var1 != Var2) %>% # remove the comparisons btween the same sp (inherently will be 0), so they dont skew scaling
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(length_dist = value) %>%
  mutate(pair = paste(Var1, ",", Var2)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", "")) # remove all white spaces
head(cleaned_length_dist) # to check that this all went smoothly
```
Amazing :) Now do the same thing with beak width and depth! 

#### Beak Width

```{r}
##### first cut up the table a bit
beak_width <- morpho %>%
  mutate(common_name = str_replace_all(common_name, " ", "_")) %>%
  mutate(common_name = str_replace_all(common_name, "Lesser_Amakihi", "Anianiau")) %>% # the phylo used diff names for these T_T
  mutate(common_name = str_replace_all(common_name, "Hawaii_akepa", "Akepa")) %>%
  mutate(common_name = str_replace_all(common_name, "Crested_honeycreeper", "Akohekohe")) %>%
  filter(common_name != "Akepa") %>% # akepa has no data so remove it from the matrix
  select(common_name, beak_width) %>%
  group_by(common_name) %>%
  summarise(mean_width = mean(beak_width)) %>%
  mutate(mean_width = scale(mean_width))

# now make the pairwise distances
width_matrix=dist(beak_width)
width_matrix=as.matrix(width_matrix, labels=TRUE)
colnames(width_matrix) <- rownames(width_matrix) <- beak_width[['common_name']] #this is the only line

cleaned_width_dist <- width_matrix %>%
  melt() %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(width_dist = value) %>%
  mutate(pair = paste(Var1, ",", Var2)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", ""))
```

#### Beak Depth

```{r}
##### first cut up the table a bit
beak_depth <- morpho %>%
  mutate(common_name = str_replace_all(common_name, " ", "_")) %>%
  mutate(common_name = str_replace_all(common_name, "Lesser_Amakihi", "Anianiau")) %>% # the phylo used diff names for these T_T
  mutate(common_name = str_replace_all(common_name, "Hawaii_akepa", "Akepa")) %>%
  mutate(common_name = str_replace_all(common_name, "Crested_honeycreeper", "Akohekohe")) %>%
  filter(common_name != "Akepa") %>% # akepa has no data so remove it from the matrix,
  select(common_name, beak_depth) %>%
  group_by(common_name) %>%
  summarise(mean_depth = mean(beak_depth)) %>%
  mutate(mean_depth = scale(mean_depth))

# now make the pairwise distances
depth_matrix=dist(beak_depth)
depth_matrix=as.matrix(depth_matrix, labels=TRUE)
colnames(depth_matrix) <- rownames(depth_matrix) <- beak_depth[['common_name']] #this is the only line

cleaned_depth_dist <- depth_matrix %>%
  melt() %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(depth_dist = value) %>%
  mutate(pair = paste(Var1, ",", Var2)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", ""))
```

### Mosleh et al morphological data
```{r}
# clean up names---------------- 
morpho_3d <- morpho_3d %>%
  mutate(common_name = str_replace_all(common_name, " ", "_")) %>%
  mutate(common_name = str_replace_all(common_name, "Lesser_Amakihi", "Anianiau")) %>% # the phylo used diff names for these T_T
  mutate(common_name = str_replace_all(common_name, "Hawaii_akepa", "Akepa")) %>%
  mutate(common_name = str_replace_all(common_name, "Crested_honeycreeper", "Akohekohe"))

# Wc/(2Lc) -----------------
### clean and average the multiple specimens per sp 
W_2L_3d <- morpho_3d %>%
  select(common_name, width_2length) %>%
  group_by(common_name) %>%
  summarise(mean_width_2length = mean(width_2length)) %>% # s_norm is S~, the dimensionless S (normalized against beak scale)
  mutate(mean_width_2length = scale(mean_width_2length)) # z transform 
###  now actually make matrix
# setup
W_2L_matrix=dist(W_2L_3d)
W_2L_matrix=as.matrix(W_2L_matrix, labels=TRUE)
colnames(W_2L_matrix) <- rownames(W_2L_matrix) <- W_2L_3d[['common_name']] #this is the line that keeps the sp names
# make matrix now 
cleaned_W_2L_dist <- W_2L_matrix %>%
  melt() %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(W_2L_dist = value) %>%
  mutate(A_standard = pmin(Var1, Var2), B_standard = pmax(Var1, Var2)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% # only keep columns with distinct columns of A and B, which should both be sorted/factored so that dupes have the same A and B col 
  mutate(pair = paste(A_standard, ",", B_standard)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", "")) %>%
  select(W_2L_dist, Var1, Var2, pair)

# sharpening rate (s)---------------------
s_3d <- morpho_3d %>%
  select(common_name, S_norm) %>%
  group_by(common_name) %>%
  summarise(mean_s_norm = mean(S_norm)) %>% # s_norm is S~, the dimensionless S (normalized against beak scale)
  mutate(mean_s_norm = scale(mean_s_norm)) # z transform
###  now actually make matrix
# setup
s_matrix=dist(s_3d)
s_matrix=as.matrix(s_matrix, labels=TRUE)
colnames(s_matrix) <- rownames(s_matrix) <- s_3d[['common_name']] #this is the  line to store sp names
# make matrix now 
cleaned_s_dist <- s_matrix %>%
  melt() %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(s_dist = value) %>%
  mutate(A_standard = pmin(Var1, Var2), B_standard = pmax(Var1, Var2)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% # only keep columns with distinct columns of A and B, which should both be sorted/factored so that dupes have the same A and B col 
  mutate(pair = paste(A_standard, ",", B_standard)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", "")) %>%
  select(s_dist, Var1, Var2, pair)

```

### Phylogenetic data

Now to generate the pairwise phylogenetic distances :)
```{r}
#generate phylo pairwise dist matrix
phylo_dist <- cophenetic.phylo(tree) 

# cleaning for mosleh et al ------
phylo_dist_3d <- phylo_dist %>%
  melt() %>%
  filter(Var1 != Var2) %>%
  filter(Var1 != "Maui_Amakihi") %>% # no morpho data for maui amakihi, remove
  filter(Var2 != "Maui_Amakihi") %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(phylo_dist = value) %>%
  mutate(A_standard = pmin(Var1, Var2), B_standard = pmax(Var1, Var2)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% # only keep columns with distinct columns of A and B, which should both be sorted/factored so that dupes have the same A and B col 
  mutate(pair = paste(A_standard, ",", B_standard)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", "")) %>%
  select(phylo_dist, Var1, Var2, pair)


# cleaning for AVONET-----------------
cleaned_phylo_dist <- phylo_dist %>%
  melt() %>% #turn matrix into a dataframe
  filter(Var1 != Var2) %>%
  filter(Var1 != "Akepa") %>% # no morpho data for Akepa/Hawaii Akepa, remove
  filter(Var2 != "Akepa") %>%
  filter(Var1 != "Maui_Amakihi") %>% # no morpho data for maui amakihi, remove
  filter(Var2 != "Maui_Amakihi") %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(phylo_dist = value) %>%
  mutate(pair = paste(Var1, ",", Var2)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", "")) 
```


### Joining phylo data to morpho data
#### Mosleh et al data
```{r}
# s-----------------------
s_3d_phylo <- cleaned_s_dist %>%
  left_join(phylo_dist_3d, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% # only keep columns with distinct columns of A and B, which should both be sorted/factored so that dupes have the same A and B col 
  select(pair, s_dist, phylo_dist)

#Wc/2Lc -----------------
W_2L_3d_phylo <- cleaned_W_2L_dist %>%
  left_join(phylo_dist_3d, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% # only keep columns with distinct columns of A and B, which should both be sorted/factored so that dupes have the same A and B col 
  select(pair, W_2L_dist, phylo_dist)
```


#### AVONET data
```{r}
# length
scaled_length_dist <- cleaned_length_dist %>%
  left_join(cleaned_phylo_dist, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% # only keep columns with distinct columns of A and B, which should both be sorted/factored so that dupes have the same A and B col 
  select(pair, length_dist, phylo_dist)

# width
scaled_width_dist <- cleaned_width_dist %>%
  left_join(cleaned_phylo_dist, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% 
  select(pair, width_dist, phylo_dist) 

# depth
scaled_depth_dist <- cleaned_depth_dist %>%
  left_join(cleaned_phylo_dist, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% 
  select(pair, depth_dist, phylo_dist)

```


#### All morpho

This is not the right way to do this but just for now: let's make a version of these distance dataframes that averages all the morphology in one :)
```{r}
scaled_morpho_dist <- cleaned_length_dist %>%
  left_join(cleaned_width_dist, by = join_by(pair)) %>%
  left_join(cleaned_depth_dist, by = join_by(pair)) %>%
  left_join(cleaned_phylo_dist, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>%
  select(pair, length_dist, depth_dist, width_dist, phylo_dist) %>%
  mutate(avg_morpho_dist = rowMeans(select(.,ends_with("h_dist")))) %>%
  select(pair, avg_morpho_dist, phylo_dist)

```


## Modeling + Plotting

Matching the phylo and morpho datasets was quite frustrating, not only did the phylogeny use an inconsistent mix of common and 'ōlelo names, the capitalization was inconsistent and not all species were represented in both datasets. Leading to one of my biggest time sinks, figuring out why all the pairwise distance dataframes were different lengths. T_T  

But now that we cleaned that up so diligently above, lets move on to plotting! In addition, let's see how a basic linear model fits the data for funsies lol

### Mosleh et al + Lerner phylo

#### Sharpening rate (s)
```{r}
ggplot(s_3d_phylo, aes(x = phylo_dist, y = s_dist)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  labs(title = "Pairwise distances",
       subtitle = "S (sharpening rate) distance vs phylogenetic distance",
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "S distance"
       ) + 
  theme_bw()
```

#### Wc/2Lc
```{r}
ggplot(s_3d_phylo, aes(x = phylo_dist, y = s_dist)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  labs(title = "Pairwise distances",
       subtitle = "W/2L distance vs phylogenetic distance",
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "S distance"
       ) + 
  theme_bw()
```


### AVONET data

#### Beak length

```{r, beak_length}
ggplot(scaled_length_dist, aes(x = phylo_dist, y = length_dist)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  labs(title = "Pairwise distances",
       subtitle = "Beak length difference vs phylogenetic distance",
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "Morphological distance"
       ) + 
  theme_bw()
```


#### Beak width
```{r, beak_width}
ggplot(scaled_width_dist, aes(x = phylo_dist, y = width_dist)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Pairwise distances",
       subtitle = "Beak width difference vs phylogenetic distance", 
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "Morphological distance"
       ) + 
  theme_bw()
```

#### Beak depth
```{r, beak_depth}
ggplot(scaled_depth_dist, aes(x = phylo_dist, y = depth_dist)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  labs(title = "Pairwise distances",
       subtitle = "Beak depth difference vs phylogenetic distance",
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "Morphological distance"
       ) + 
  theme_bw()
```

#### Model making
```{r}
depth_mod <- lm(depth_dist~phylo_dist, data = scaled_depth_dist)
Anova(depth_mod)
resid_panel(depth_mod, plots = c("resid", "qq", "lev", "hist"))
```


The phylo dist of 6 has a wierd gap, this seems to be because the maui parrotbill, compared to all the sp ~6 phylo dist away (amakihis), has high morphological beak depth dist. Meanwhile, these sp compared to it's sister, the akipolaau has lower morpho dist to everyone. Makes sense considering the high beak depth of the maui parrotbill's compared to all the amakihis.

#### Average of morpho
```{r, avg_morpho}
ggplot(scaled_morpho_dist, aes(x = phylo_dist, y = avg_morpho_dist)) +
  geom_point() +
  geom_smooth(method = "lm") +
  labs(title = "Pairwise distances",
       subtitle = "Averaged beak length, depth, and width difference vs phylogenetic distance",
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "Average morphological distance"
       ) + 
  theme_bw()

sig <- sd(scaled_morpho_dist$avg_morpho_dist) # saving standard deviation of this plot
```

## Discussion

### Null model of trait evolution

Conveniently, there is an R function to do this within phytools :0
I am just simulating one trait - the average morpho 

####OLD SCRIPT: 
```{r}
# simulate Brownian evolution on tree, just do avg of all morpho diff--------
# make sure the tips and morpho are the same length 
x <- fastBM(tree, sig2 = sig^2, internal = TRUE) # sig from mean morpho above
phenogram(tree, x, spread.labels = TRUE, spread.cost = c(1, 0)) # visualize Brownian evolution on a tree, spread cost just makes sure labels don't overlap

#store data in df, clean up a bit----------
morpho_sim <- data.frame(x)
  
morpho_sim <- morpho_sim %>%
  mutate(species = rownames(morpho_sim)) %>%
  filter(!str_detect(species, "[0-9]")) %>% # only select rows of tip sp
  mutate(species = str_to_lower(species))

# now make the pairwise distances----------
sim_matrix=dist(morpho_sim)
sim_matrix=as.matrix(sim_matrix, labels=TRUE)


cleaned_sim_dist <- sim_matrix %>%
  melt() %>%
  filter(Var1 != Var2) %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(sim_dist = value) %>%
  mutate(pair = paste(Var1, ",", Var2)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", ""))

# other phylo dist had some stuff removed to match the avonet data so remake -------
phylo_dist <- cophenetic.phylo(tree) # make pairwise matrix of phylogenetic distances

cleaned_phylo_dist_full <- phylo_dist %>%
  melt() %>% #turn matrix into a dataframe
  filter(Var1 != Var2) %>%
  mutate(Var1 = str_to_lower(Var1)) %>% # make everything lowercase to make the matching easier 
  mutate(Var2 = str_to_lower(Var2)) %>%
  rename(phylo_dist = value) %>%
  mutate(pair = paste(Var1, ",", Var2)) %>% # make 1 col w both pair names
  mutate(pair = str_replace_all(pair, " ", ""))

#now put the two together ----------
scaled_sim_dist <- cleaned_sim_dist %>%
  left_join(cleaned_phylo_dist_full, by = join_by(pair)) %>%
  mutate(A_standard = pmin(Var1.x, Var2.x), B_standard = pmax(Var1.x, Var2.x)) %>% # create temp columns for sorting purposes, with A always having the name that is first alphabetically
  distinct(A_standard, B_standard, .keep_all = TRUE) %>% 
  select(pair, sim_dist, phylo_dist)
```


####NEW: 
for AVONET data: 
``` {r}
# For AVONET data -----------------------------------
tree_trim <- tree %>%
  drop.tip(c("Akepa", "Maui_Creeper"))

# trying vgam function to extract 
#Quantiles corresponding to cumulative proportions of a distribution. E.g., the 95% quantile is the value for which 95% of the data will be smaller than that value.
# folded normal dist (normal dist of abs value) 95% quantile 

# bm quantile generation for length------------------
length_sd <- bmMLE(tree_trim, as.vector(beak_length$mean_length_culmen)) # generate sd

bm_l <- qfoldnorm(0.95, mean = 0, sd = sqrt(cleaned_phylo_dist$phylo_dist * length_sd$s2)) 
bm_length <- data.frame(phylo_dist = cleaned_phylo_dist$phylo_dist, 
                        morpho_dist = bm_l, 
                        pair = cleaned_phylo_dist$pair)

# bm quantile generation for width------------------
width_sd <- bmMLE(tree_trim, as.vector(beak_width$mean_width))

bm_w <- qfoldnorm(0.95, mean = 0, sd = sqrt(cleaned_phylo_dist$phylo_dist * width_sd$s2)) # 
bm_width <- data.frame(phylo_dist = cleaned_phylo_dist$phylo_dist, 
                        morpho_dist = bm_w, 
                        pair = cleaned_phylo_dist$pair)

# bm quantile generation for depth------------------
depth_sd <- bmMLE(tree_trim, as.vector(beak_depth$mean_depth))

bm_d <- qfoldnorm(0.95, mean = 0, sd = sqrt(cleaned_phylo_dist$phylo_dist * depth_sd$s2)) 
bm_depth <- data.frame(phylo_dist = cleaned_phylo_dist$phylo_dist, 
                        morpho_dist = bm_d, 
                        pair = cleaned_phylo_dist$pair)

# general morpho (NOT DONE YET)
bm_val <- qfoldnorm(0.95, mean = 0, sd = sqrt(cleaned_phylo_dist$phylo_dist * sig^2)) 
bm_morpho <- data.frame(phylo_dist = cleaned_phylo_dist$phylo_dist, 
                        morpho_dist = bm_val, 
                        pair = cleaned_phylo_dist$pair)

#test plot
ggplot(bm_length, aes(x = phylo_dist, y = morpho_dist)) +
  geom_point() +
  geom_line() +
  geom_area(fill = "skyblue", alpha = .3) +
  labs(title = "Pairwise distances",
       subtitle = "Simulated morphological distance vs phylogenetic distance",
       x = "Phylogenetic distance", 
       y = "simulated morphological distance (95% quantile)"
       ) + 
  theme_bw()

```

For Mosleh et al data:
```{r}
# trim out maui amakihi
tree_3d <- tree %>%
  drop.tip("Maui_Amakihi")
# trying vgam function to extract 
#Quantiles corresponding to cumulative proportions of a distribution. E.g., the 95% quantile is the value for which 95% of the data will be smaller than that value.
# folded normal dist (normal dist of abs value) 95% quantile 

plot(tree_3d)
# s----------------------------
# first bm quantile generation
s_sd <- bmMLE(tree_3d, as.vector(s_3d$mean_s_norm))
bm_s <- qfoldnorm(0.95, mean = 0, sd = sqrt(phylo_dist_3d$phylo_dist * s_sd$s2)) # sd of the data might be overestimated if pulled frmo real data, try vcv to see if this changes anything
bm_s <- data.frame(phylo_dist = phylo_dist_3d$phylo_dist, 
                        morpho_dist = bm_s, 
                        pair = phylo_dist_3d$pair)

# W/2L --------------
# first bm quantile generation
W_2L_sd <- bmMLE(tree_3d, as.vector(W_2L_3d$mean_width_2length))
bm_W_2L <- qfoldnorm(0.95, mean = 0, sd = sqrt(phylo_dist_3d$phylo_dist * W_2L_sd$s2)) 
bm_W_2L <- data.frame(phylo_dist = phylo_dist_3d$phylo_dist, 
                        morpho_dist = bm_W_2L, 
                        pair = phylo_dist_3d$pair)
```

#### Model making
```{r}
sim_mod <- lm(sim_dist~phylo_dist, data = scaled_sim_dist)
Anova(sim_mod)
resid_panel(sim_mod, plots = c("resid", "qq", "lev", "hist"))
```

As expected, the basic linear model fits this simulated data well and shows significant effect of phylo dist on morpho dist. Also, the residual panels show good fit. 

#### Plotting

Whew, ok now time to plot this data! 

```{r, brownian_dist}
ggplot(scaled_sim_dist, aes(x = phylo_dist, y = sim_dist)) +
  geom_point() +
  geom_smooth(method = 'lm') +
  labs(title = "Pairwise distances",
       subtitle = "Simulated morphological distance vs phylogenetic distance",
       caption = "all data transformed via z-score normalization", 
       x = "Phylogenetic distance", 
       y = "Average morphological distance"
       ) + 
  theme_bw()
```

**Code for sim found in this [phytools exercise](http://phytools.org/eqg/Exercise_4.1/)**

This null model is based on Brownian motion, a common null model for trait evolution:  
z(t)∼N(z(0),σ^2^t)  
where z is a trait value at time (t). N indicates it will follow a normal distribution, and σ^2^ is variance. 

In a perfect world, my data would be more evely distributed along the whole range of phylogenetic distances and therefore the confidence intervals displayed would follow a pattern of being smaller at lower phylo dist, and wider at higher dist. 
<!-- Simply put, this model says assumes no evolutionary direction. It assumes that pairwise morphological distance will increase in variance as pairwise phylogenetic distance increases, following a normal distribution. The mean morphological distance at any point in time will remain 0. I will calculate the variance from the data. '  -->

### Conclusion
AVONET: 
```{r}

combined <- ggplot() +
  # plot avg morpho dist overlayed with bm area
  geom_point(scaled_morpho_dist, mapping = aes(x = phylo_dist, y = avg_morpho_dist))+
  geom_smooth(scaled_morpho_dist, mapping = aes(x = phylo_dist, y = avg_morpho_dist), method = 'lm') +
  geom_point(bm_morpho, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_line(bm_morpho, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_area(bm_morpho, mapping = aes(x = phylo_dist, y = morpho_dist), fill = "skyblue", alpha = .3) +
  # length---------------
  ggplot() +
  geom_point(scaled_length_dist, mapping = aes(x = phylo_dist, y = length_dist)) +
  geom_smooth(scaled_length_dist, mapping = aes(x = phylo_dist, y = length_dist), method = 'lm') +
  geom_point(bm_length, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_line(bm_length, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_area(bm_length, mapping = aes(x = phylo_dist, y = morpho_dist), fill = "skyblue", alpha = .3) +
  #width-----------------
  ggplot() +
  geom_point(scaled_width_dist, mapping = aes(x = phylo_dist, y = width_dist)) +
  geom_smooth(scaled_width_dist, mapping = aes(x = phylo_dist, y = width_dist), method = "lm")+ 
  geom_point(bm_width, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_line(bm_width, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_area(bm_width, mapping = aes(x = phylo_dist, y = morpho_dist), fill = "skyblue", alpha = .3) +
  # depth--------------
  ggplot() +
  geom_point(scaled_depth_dist, mapping = aes(x = phylo_dist, y = depth_dist)) +
  geom_smooth(scaled_depth_dist, mapping = aes(x = phylo_dist, y = depth_dist), method = 'lm') + 
  geom_point(bm_depth, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_line(bm_depth, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_area(bm_depth, mapping = aes(x = phylo_dist, y = morpho_dist), fill = "skyblue", alpha = .3)

combined &
  ylim (0, 8)
  
```

Mosleh et al: 
```{r}

combined <- ggplot() +
  # s -----------------------
  geom_point(s_3d_phylo, mapping = aes(x = phylo_dist, y = s_dist))+
  geom_smooth(s_3d_phylo, mapping = aes(x = phylo_dist, y = s_dist), method = 'lm') +
  geom_point(bm_s, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_line(bm_s, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_area(bm_s, mapping = aes(x = phylo_dist, y = morpho_dist), fill = "skyblue", alpha = .3) +
  # W/2L -------------------
  ggplot() +
  geom_point(W_2L_3d_phylo, mapping = aes(x = phylo_dist, y = W_2L_dist)) +
  geom_smooth(W_2L_3d_phylo, mapping = aes(x = phylo_dist, y = W_2L_dist), method = 'lm') +
  geom_point(bm_W_2L, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_line(bm_W_2L, mapping = aes(x = phylo_dist, y = morpho_dist), color = "blue") +
  geom_area(bm_W_2L, mapping = aes(x = phylo_dist, y = morpho_dist), fill = "skyblue", alpha = .3) 
 

combined
  
```

#### Selecting points above the line :D
```{r}
# s ---------------------------
s_greater_than_bm <- s_3d_phylo %>%
  inner_join(bm_s, by = join_by(phylo_dist)) %>%
  filter(s_dist > morpho_dist) %>%
  select(!pair.y) %>%
  mutate(diff = (s_dist - morpho_dist)) %>%
  distinct()

# plot phylo_dist and greatest diff, basically zooming in to the points that are above line
ggplot(s_greater_than_bm, aes(x = phylo_dist, y = diff)) + 
  geom_point()

# sum the diff each sp has
s_greater_bm_by_sp <- s_greater_than_bm %>%
  separate(col = pair.x, into = c("sp1", "sp2"), sep = ",") %>%
  mutate(sp_a = pmin(sp1, sp2), sp_b = pmax(sp1, sp2)) %>%
  select(!c(sp1, sp2)) %>%
  pivot_longer(cols = c(sp_a, sp_b), names_to = "role", values_to = "sp") %>%
  group_by(sp) %>%
  summarise(diff = sum(diff), .groups = "drop")

  
# w/2l ----------------------
W_2L_greater_than_bm <- W_2L_3d_phylo %>%
  inner_join(bm_W_2L, by = join_by(phylo_dist)) %>%
  filter(W_2L_dist > morpho_dist) %>%
  select(!pair.y) %>%
  mutate(diff = (W_2L_dist - morpho_dist)) %>%
  distinct()

# plot phylo_dist and greatest diff, basically zooming in to the points that are above line
ggplot(W_2L_greater_than_bm, aes(x = phylo_dist, y = diff)) + 
  geom_point()

# sum the diff each sp has
W_2L_greater_bm_by_sp <- W_2L_greater_than_bm %>%
  separate(col = pair.x, into = c("sp1", "sp2"), sep = ",") %>%
  mutate(sp_a = pmin(sp1, sp2), sp_b = pmax(sp1, sp2)) %>%
  select(!c(sp1, sp2)) %>%
  pivot_longer(cols = c(sp_a, sp_b), names_to = "role", values_to = "sp") %>%
  group_by(sp) %>%
  summarise(diff = sum(diff), .groups = "drop")
```

#### diff per diet
```{r}
morpho_3d_diet <- morpho_3d %>%
  mutate(sp = str_to_lower(common_name)) %>%
  select(sp, diet.y) %>% #setup data to be joined to s data 
  distinct()

# s------------------------------
s_greater_bm_diet <- s_greater_than_bm %>%
  separate(col = pair.x, into = c("sp1", "sp2"), sep = ",") %>%
  mutate(sp_a = pmin(sp1, sp2), sp_b = pmax(sp1, sp2)) %>%
  select(!c(sp1, sp2)) %>%
  pivot_longer(cols = c(sp_a, sp_b), names_to = "role", values_to = "sp") %>%
  left_join(morpho_3d_diet) %>%
  group_by(diet.y) %>%
  summarise(diff_sum = sum(diff), num_sp = n_distinct(sp), stdev = sd(diff)) %>%
  mutate(avg_diff = diff_sum/num_sp) 

# W/2L---------------------------
W_2L_bm_by_diet <- W_2L_greater_than_bm %>%
  separate(col = pair.x, into = c("sp1", "sp2"), sep = ",") %>%
  mutate(sp_a = pmin(sp1, sp2), sp_b = pmax(sp1, sp2)) %>%
  select(!c(sp1, sp2)) %>%
  pivot_longer(cols = c(sp_a, sp_b), names_to = "role", values_to = "sp") %>%
  left_join(morpho_3d_diet) %>%
  group_by(diet.y) %>%
  summarise(diff_sum = sum(diff), num_sp = n_distinct(sp), stdev = sd(diff)) %>%
  mutate(avg_diff = diff_sum/num_sp) # only 1 insectivore, maui parrotbill with palila 

W_2L_greater_bm_by_sp$sp # these are the sp significantly diff from BM

```

```{r}
ggplot(s_greater_bm_diet, aes(x = diet.y, y = avg_diff)) +
  geom_col() + 
  geom_errorbar(aes(ymin = (avg_diff - stdev), ymax = (avg_diff + stdev)))
ggplot(W_2L_bm_by_diet, aes(x = diet.y, y = avg_diff)) +
  geom_col() + 
  geom_errorbar(aes(ymin = (avg_diff - stdev), ymax = (avg_diff + stdev)))
```

 W_2L_bm_by_d
For S - the one "insectivore, tree sap" sp is the akiapoaau lol. besides that, the nectivore, insectivore group has the highest average diff only counting the sp above BM line. 
For W/2L - the "mamane seeds" sp is the palila. Interestingly, has a similar sum of diff as the akiapolaau's sharpening rate diff

notes:
find trendline for the BM model 
which taxa are outliers 
directionality 
bin ,create syndromes

If speciation happens most when species find new, unoccupied niche space and then adapt to it (ecological release), it would show up on my above graphs as a generically negative correlation, with smaller phylogenetic distance yielding high morphological distance, and higher phylogenetic distance yielding possibly lower morphological distance (with greater variance).  

The real-life data definetly has a tighter spread compared to the BM-modeled data, and generally seems to have a shallower slope. 

The results are muddled, with seemingly little effect of phylogenetic distance on morphological distance, positive or negative. The null model shows a significant effect of phylo dist on morpho dist, as well as beak depth. Idk ^^'

In terms of improving my current results, I have two ideas:  

1. I think I just need more resolution. So more data points. Adding species (especially extinct ones) to the phylogeny and morphology datasets would probably help tremendously.  
2. Phylogenetic distance did show ability as a predictor for beak width, indicating that maybe certain beak dimensions do just follow basic brownian motion, while others are affected by ecological effects. To me, this indicates necessity to be able to capture more dimensions of beak variation (not just length, width, and depth) such as curvature, symmetry of upper and lower mandible, etc. 



# trying to sim fold norm data
```{r}
# s---------------------------------------
nsim = 20 #sample.size = how many values to generate at each time step
time = seq(0, 11.552685, length.out = 20) #nsim = 10 equidistent time steps (defined by length.out)  
# greatest phyol_dist is 11.552685)

# Setup storage matrix: rows = time points, columns = simulations
morpho_dist_matrix <- matrix(nrow = length(time), ncol = nsim)

# Loop by index, not value
for (i in seq_along(time)) {
  # simulate 20 values using fold norm distribution
  test <- rfoldnorm(nsim, mean = 0, sd = sqrt(time[i] * s_sd$s2))  
  
  # Save to row i of the matrix
  morpho_dist_matrix[i, ] <- test
}


morpho_df_s <- as.data.frame(morpho_dist_matrix)
rownames(morpho_df_s) <- paste0("time_", round(time, 2))
colnames(morpho_df_s) <- paste0("sim_", 1:nsim)

morpho_sim_s <- morpho_df_s %>%
  mutate(across(everything(), ~replace_na(., 0))) %>%
  rownames_to_column() %>%
  mutate(time = rowname) %>%
  pivot_longer(cols = sim_1:sim_20) %>%
  mutate(time = str_remove(time, "time_")) %>%
  select(!rowname) %>%
  rename(phylo_dist = time, morpho_dist = value) %>%
  mutate(phylo_dist = as.numeric(phylo_dist))

ggplot(morpho_sim_s, aes(x = phylo_dist, y = morpho_dist))+ 
  geom_point() + 
  geom_smooth(method = "lm") # doesn't show up???

# W/2L---------------------------------------
nsim = 20 #sample.size = how many values to generate at each time step
time = seq(0, 11.552685, length.out = 20) #nsim = 10 equidistant time steps (defined by length.out)  
# greatest phyol_dist is 11.552685)

# Setup storage matrix: rows = time points, columns = simulations
morpho_dist_matrix <- matrix(nrow = length(time), ncol = nsim)

# Loop by index, not value
for (i in seq_along(time)) {
  # simulate 20 values using fold norm distribution
  test <- rfoldnorm(nsim, mean = 0, sd = sqrt(time[i] * s_sd$s2))  
  
  # Save to row i of the matrix
  morpho_dist_matrix[i, ] <- test
}


morpho_df_W_2L <- as.data.frame(morpho_dist_matrix)
rownames(morpho_df_W_2L) <- paste0("time_", round(time, 2))
colnames(morpho_df_W_2L) <- paste0("sim_", 1:nsim)

morpho_sim_W_2L <- morpho_df_W_2L %>%
  mutate(across(everything(), ~replace_na(., 0))) %>%
  rownames_to_column() %>%
  mutate(time = rowname) %>%
  pivot_longer(cols = sim_1:sim_20) %>%
  mutate(time = str_remove(time, "time_")) %>%
  select(!rowname) %>%
  rename(phylo_dist = time, morpho_dist = value) %>%
  mutate(phylo_dist = as.numeric(phylo_dist))

ggplot(morpho_sim_W_2L, aes(x = phylo_dist, y = morpho_dist))+ 
  geom_point() + 
  geom_smooth(method = "lm") 
```

